# RAG Chat Storage Microservice

A production-ready Spring Boot microservice for storing and managing chat histories generated by RAG (Retrieval-Augmented Generation) based chatbot systems. This service provides secure session management, message storage, and comprehensive API endpoints with authentication, rate limiting, and error handling.

## Table of Contents

- [Features](#features)
- [Technology Stack](#technology-stack)
- [Setup Instructions](#setup-instructions)
- [Docker Setup](#docker-setup)
- [Quick Start](#quick-start)
  - [Accessing H2 Database Console](#accessing-h2-database-console)
- [API Documentation](#api-documentation)
- [Environment Configuration](#environment-configuration)
- [Architecture Decisions](#architecture-decisions)
- [Testing](#testing)
- [Troubleshooting](#troubleshooting)

## Features

### Core Functionalities

- ‚úÖ **Session Management**: Create, retrieve, rename, favorite, and delete chat sessions
- ‚úÖ **Message Storage**: Store messages with sender, content, and optional context
- ‚úÖ **Pagination**: Efficient message retrieval with pagination support
- ‚úÖ **API Key Authentication**: Secure API access with primary/secondary key support
- ‚úÖ **Rate Limiting**: Rate limiting per API key (60 requests per minute)
- ‚úÖ **Global Error Handling**: RFC 7807 compliant error responses
- ‚úÖ **Health Checks**: Actuator endpoints for monitoring (`/actuator/health`)
- ‚úÖ **API Documentation**: Interactive Swagger/OpenAPI documentation (`/swagger-ui.html`)
- ‚úÖ **CORS Configuration**: Configurable cross-origin resource sharing
- ‚úÖ **Database Migrations**: Flyway for schema versioning
- ‚úÖ **Unit Tests**: Comprehensive test coverage with JaCoCo reports

### Security Features

- API key authentication with rotation support (primary/secondary keys)
- Input validation and sanitization
- SQL injection prevention (parameterized queries)
- XSS prevention (Content-Type enforcement)
- Rate limiting per API key
- H2 console disabled in production

## Technology Stack

- **Java**: 17
- **Spring Boot**: 3.3.5
- **Database**: H2 (file-based, embedded)
- **Build Tool**: Maven
- **Migration**: Flyway
- **API Documentation**: SpringDoc OpenAPI 3
- **Rate Limiting**: Bucket4j
- **Security**: Spring Security
- **Testing**: JUnit 5, Mockito, JaCoCo

## Setup Instructions

### Docker Setup

### Prerequisites

- Docker 20.10+ installed
- Docker Compose 2.0+ installed
- At least 2GB free disk space

### Quick Start (3 Steps)

#### 1. Generate and Set API Key

```bash
# Generate API key (Recommended)
openssl rand -hex 16

# Create .env file from example or use env.dev file
cp env.example .env

# Edit .env and set your API key
# Open .env in your editor and add:
# API_KEY_PRIMARY=your-generated-api-key-here or custom key 
```

#### 2. Build and Run

```bash
docker-compose up --build
```

#### 3. Access the Application

Once the container is running, access:

- **API Base URL**: `http://localhost:8080/api/v1`
- **Swagger UI**: `http://localhost:8080/swagger-ui.html`
- **Health Check**: `http://localhost:8080/actuator/health`
- **H2 Console**: `http://localhost:8080/h2-console` (if `ENABLE_H2_CONSOLE=true`)
- **For more information about H2 console : [Accessing H2 Database Console](#accessing-h2-database-console)
### Docker Setup Options

**Recommended: Using .env File**

```bash
# Create .env file from example
cp env.example .env

# Edit .env and set your API key and other settings
# API_KEY_PRIMARY=your-api-key-here
# SPRING_PROFILES_ACTIVE=dev
# ENABLE_H2_CONSOLE=true
# LOG_LEVEL=INFO

# Run Docker Compose (automatically reads .env file)
docker-compose up --build
```

**Alternative: Using Environment Variables**

If you prefer to use environment variables instead of .env file:

```bash
export API_KEY_PRIMARY=your-api-key-here
export SPRING_PROFILES_ACTIVE=dev
export ENABLE_H2_CONSOLE=true
export LOG_LEVEL=INFO
docker-compose up --build
```

### Docker Commands

**Start in background (detached mode):**
```bash
docker-compose up -d --build
```

**View logs:**
```bash
# All logs
docker-compose logs -f

# Specific service logs
docker-compose logs -f ragchat-storage

# Last 100 lines
docker-compose logs --tail=100 ragchat-storage
```

**Stop the application:**
```bash
docker-compose down
```

**Stop and remove volumes (clears database data):**
```bash
docker-compose down -v
```

**Rebuild from scratch:**
```bash
docker-compose up --build --force-recreate
```

**Check container status:**
```bash
docker-compose ps
```

### Data Persistence

- **Database files**: Stored in `./data/ragchat.mv.db` (persists across restarts)
- **Log files**: Stored in `./logs/` directory (mounted as volume)
- Both directories are created automatically and persist data between container restarts

### Local Setup

#### Prerequisites

- Java 17 or higher
- Maven 3.6+ (or use included Maven Wrapper `./mvnw`)

#### Step-by-Step Local Setup

##### 1. Clone the Repository

```bash
git clone <repository-url>
cd RAGChatStorageService
```

##### 2. Create API Key

Create a secure API key for authentication:

**Recommended**: You can generate a secure key using the command below:

```bash
# Generate a random API key (32 characters)
openssl rand -hex 16
```

Save this key - you'll need it in the next step.

##### 3. Configure Environment Variables

The application automatically loads environment variables from a `.env` file in the project root.

**Option A: Create .env file from template (Recommended)**

```bash
# Copy the example environment file
cp env.example .env

# Edit .env and set your API key
# Open .env in your editor and set:
# API_KEY_PRIMARY=your-generated-api-key-here
```

**Option B: Use profile-specific environment file**

For development, you can use the provided `env.dev` file:

```bash
# Copy env.dev to .env
cp env.dev .env

# Edit .env and update API_KEY_PRIMARY with your generated key
```

**Option C: Set environment variables directly**

If you prefer not to use a `.env` file, you can set environment variables directly:

```bash
export API_KEY_PRIMARY=your-generated-api-key-here
export SPRING_PROFILES_ACTIVE=dev
export ENABLE_H2_CONSOLE=true
export LOG_LEVEL=DEBUG
```

**Note**: Using `.env` file is recommended as it persists your configuration and doesn't require exporting variables each time.

##### 4. Build the Project

```bash
# Install dependencies and build
./mvnw clean install
```

##### 5. Run the Application

```bash
# Start the application
./mvnw spring-boot:run
```

The application will start on `http://localhost:8080` (or the port specified in `SERVER_PORT`).

##### 6. Verify the Application

Once started, verify the application is running:

```bash
# Check health endpoint
curl http://localhost:8080/actuator/health

# Expected response: {"status":"UP"}
```

##### 7. Access Endpoints

After successful startup, you can access:

- **API Base URL**: `http://localhost:8080/api/v1`
- **Swagger UI**: `http://localhost:8080/swagger-ui.html`
- **Health Check**: `http://localhost:8080/actuator/health`
- **H2 Console**: `http://localhost:8080/h2-console` (dev profile only)



## Quick Start

### Local Development

1. **Set up environment** (see [Local Setup](#local-setup))
2. **Start the application**: `./mvnw spring-boot:run`
3. **Access Swagger UI**: `http://localhost:8080/swagger-ui.html`
4. **Test API**: Use the provided Postman collection (`docs/RAG_Chat_Storage.postman_collection.json`)

### Using Docker

1. **Create .env file**: Copy `env.example` to `.env` and set `API_KEY_PRIMARY=your-api-key`
2. **Start container**: `docker-compose up --build`
3. **Access endpoints**: See [Docker Setup](#docker-setup) section above

### Accessing H2 Database Console

The H2 database console is available when running with the `dev` profile (enabled by default). This allows you to browse and query the database directly through a web interface.

**Steps to Access:**

1. **Ensure H2 Console is enabled**
   - The console is automatically enabled in the `dev` profile
   - Verify `ENABLE_H2_CONSOLE=true` in your `.env` file or environment variables

2. **Navigate to H2 Console**
   - Open your browser and go to: `http://localhost:8080/h2-console`

3. **Enter Connection Details**
   - **JDBC URL**: 
     - **Local (non-Docker)**: `jdbc:h2:file:./data/ragchat`
     - **Docker**: `jdbc:h2:file:/app/data/ragchat` (use absolute path inside container)
     - For QA profile: `jdbc:h2:file:./data/ragchat-qa` (local) or `jdbc:h2:file:/app/data/ragchat-qa` (Docker)
   - **Username**: `sa`
   - **Password**: (leave blank/empty)
   - **Driver Class**: `org.h2.Driver` (auto-filled)

4. **Click "Connect"**

**Example Connection Settings:**
```
Saved Settings: Generic H2 (Embedded)
Setting Name: Generic H2 (Embedded)
Driver Class: org.h2.Driver
JDBC URL: jdbc:h2:file:./data/ragchat
User Name: sa
Password: (leave blank)
```

**Note**: 
- The H2 console is **disabled in production** for security reasons
- **For Docker**: Make sure `ENABLE_H2_CONSOLE=true` is set in your environment variables or `.env` file
- **For Docker**: Use absolute path in JDBC URL: `jdbc:h2:file:/app/data/ragchat` (not `./data/ragchat`)
- The database file is located at:
  - **Local**: `./data/ragchat.mv.db` (relative to application working directory)
  - **Docker**: `/app/data/ragchat.mv.db` (inside container, mounted from `./data` on host)
- You can run SQL queries directly in the console to inspect data

## API Documentation

### Base URL

All API endpoints are prefixed with `/api/v1`.

### Authentication

All API requests (except health checks and Swagger UI) require an API key in the request header:

```
X-API-Key: your-api-key-here
```

### Rate Limiting

- **Per API Key**: 60 requests per minute (default, configurable via `RATE_LIMIT_API_KEY_PER_MINUTE`)

When rate limit is exceeded, the API returns `429 Too Many Requests` with a `Retry-After` header.

### API Endpoints

> **üí° Tip**: For easy testing, use the provided Postman collection: `docs/RAG_Chat_Storage.postman_collection.json`. Import it into Postman and configure the `baseUrl` and `apiKey` variables.

#### Session Management

##### Create Session

```http
POST /api/v1/sessions
Content-Type: application/json
X-API-Key: your-api-key

{
  "userId": "user123",
  "title": "My Chat Session"
}
```

**Response (201 Created):**
```json
{
  "id": 1,
  "userId": "user123",
  "title": "My Chat Session",
  "isFavorite": false,
  "createdAt": "2026-02-02T10:30:00Z",
  "updatedAt": "2026-02-02T10:30:00Z"
}
```

##### Get Sessions by User ID

```http
GET /api/v1/sessions?userId=user123
X-API-Key: your-api-key
```

**Response (200 OK):**
```json
{
  "sessions": [
    {
      "id": 1,
      "userId": "user123",
      "title": "My Chat Session",
      "isFavorite": false,
      "createdAt": "2026-02-02T10:30:00Z",
      "updatedAt": "2026-02-02T10:30:00Z"
    }
  ],
  "total": 1
}
```

##### Rename Session

```http
PATCH /api/v1/sessions/{sessionId}
Content-Type: application/json
X-API-Key: your-api-key

{
  "title": "Updated Title"
}
```

**Response (200 OK):**
```json
{
  "id": 1,
  "userId": "user123",
  "title": "Updated Title",
  "isFavorite": false,
  "createdAt": "2026-02-02T10:30:00Z",
  "updatedAt": "2026-02-02T11:00:00Z"
}
```

##### Toggle Favorite

```http
PATCH /api/v1/sessions/{sessionId}/favorite
Content-Type: application/json
X-API-Key: your-api-key

{
  "isFavorite": true
}
```

**Response (200 OK):**
```json
{
  "id": 1,
  "userId": "user123",
  "title": "My Chat Session",
  "isFavorite": true,
  "createdAt": "2026-02-02T10:30:00Z",
  "updatedAt": "2026-02-02T11:00:00Z"
}
```

##### Delete Session

```http
DELETE /api/v1/sessions/{sessionId}
X-API-Key: your-api-key
```

**Response (204 No Content)**

#### Message Management

##### Add Message

```http
POST /api/v1/sessions/{sessionId}/messages
Content-Type: application/json
X-API-Key: your-api-key

{
  "sender": "user",
  "content": "Hello, how are you?",
  "context": "{\"retrievedDocuments\": [{\"id\": \"doc1\", \"relevanceScore\": 0.95}]}"
}
```

**Valid sender values**: `user`, `assistant`, `system` (case-insensitive)

**Response (201 Created):**
```json
{
  "id": 1,
  "sessionId": 1,
  "sender": "user",
  "content": "Hello, how are you?",
  "context": "{\"retrievedDocuments\": [{\"id\": \"doc1\", \"relevanceScore\": 0.95}]}",
  "timestamp": "2026-02-02T10:35:00Z"
}
```

##### Get Messages (Paginated)

```http
GET /api/v1/sessions/{sessionId}/messages?page=0&size=20
X-API-Key: your-api-key
```

**Query Parameters:**
- `page` (optional, default: 0): Page number (0-indexed)
- `size` (optional, default: 20, max: 100): Page size

**Response (200 OK):**
```json
{
  "messages": [
    {
      "id": 1,
      "sessionId": 1,
      "sender": "user",
      "content": "Hello, how are you?",
      "context": null,
      "timestamp": "2026-02-02T10:35:00Z"
    }
  ],
  "page": 0,
  "size": 20,
  "totalElements": 1,
  "totalPages": 1
}
```

### Error Responses

All errors follow RFC 7807 Problem Details format:

```json
{
  "type": "https://ragchat.api/errors/validation-error",
  "title": "Validation Error",
  "status": 400,
  "detail": "Invalid userId format. Must match pattern: ^[a-zA-Z0-9_]+$",
  "instance": "/api/v1/sessions"
}
```

**Common Error Codes:**
- `400 Bad Request`: Invalid input or validation error
- `401 Unauthorized`: Missing or invalid API key
- `404 Not Found`: Resource not found
- `409 Conflict`: Duplicate resource (e.g., duplicate session title for same user)
- `429 Too Many Requests`: Rate limit exceeded

### Interactive API Documentation

Access Swagger UI at `http://localhost:8080/swagger-ui.html` for interactive API documentation with request/response examples.

## Environment Configuration

### Environment Variables

The application supports configuration through environment variables or a `.env` file. See `env.example` for a complete list of all available variables.

**Key Variables:**

| Variable | Description | Default | Required |
|----------|-------------|---------|----------|
| `API_KEY_PRIMARY` | Primary API key for authentication | - | Yes |
| `API_KEY_SECONDARY` | Secondary API key (for rotation) | - | No |
| `SPRING_PROFILES_ACTIVE` | Active Spring profile | `dev` | No |
| `RATE_LIMIT_API_KEY_PER_MINUTE` | Rate limit per API key | `60` | No |
| `H2_DATABASE_PATH` | H2 database file path | `./data/ragchat` | No |
| `SERVER_PORT` | Server port | `8080` | No |
| `LOG_LEVEL` | Logging level | `INFO` | No |
| `ENABLE_H2_CONSOLE` | Enable H2 console | `false` | No |

### Spring Profiles

The application supports multiple Spring profiles for different environments:

#### Development Profile (`dev`)

- H2 file-based database (data persists)
- Enhanced logging (DEBUG level)
- H2 console enabled at `/h2-console`
- Verbose error messages
- Increased rate limits (120 req/min) for testing

**Activate:**
```bash
export SPRING_PROFILES_ACTIVE=dev
```

#### QA Profile (`qa`)

- H2 file-based database (test-specific path: `./data/ragchat-qa`)
- INFO level logging
- H2 console disabled (security)
- Test-specific configurations
- Standard rate limits (60 req/min per API key)

**Activate:**
```bash
export SPRING_PROFILES_ACTIVE=qa
```

#### Production Profile (`prod`)

- H2 file-based database (persistent storage)
- WARN/ERROR level logging (reduced verbosity)
- H2 console disabled (security)
- Security hardening enabled
- Graceful shutdown configured

**Activate:**
```bash
export SPRING_PROFILES_ACTIVE=prod
```

### Profile-Specific Environment Files

The application automatically loads environment variables from profile-specific files based on the active Spring profile:

**File Loading Priority:**
1. **`.env`** (highest priority - user override, if exists)
2. **`env.{profile}`** (profile-specific, e.g., `env.qa`, `env.prod`)
3. **`env.dev`** (fallback for development)

**Available Profile Files:**
- `env.dev` - Development environment (pre-configured)
- `env.qa` - QA/testing environment
- `env.prod` - Production environment (create from `env.example`)

## Architecture Decisions

This section documents key architectural decisions made during the design and implementation of this microservice.

### ADR 001: Spring Boot Framework Choice

**Context**: Need to choose a backend framework for building a production-ready microservice for storing RAG chatbot conversations.

**Decision**: Use Spring Boot with Java.

**Rationale**:
- **Mature Ecosystem**: Spring Boot provides comprehensive libraries for enterprise applications (Spring Data JPA, Spring Security, Spring Boot Actuator)
- **Rapid Development**: Auto-configuration reduces boilerplate code, enabling faster development
- **Production-Ready Features**: Built-in support for health checks, metrics, logging, and configuration management
- **Security**: Spring Security provides robust authentication/authorization mechanisms
- **Database Integration**: Spring Data JPA offers seamless ORM with minimal configuration
- **Testing**: Excellent testing support with Spring Boot Test, MockMvc, and TestContainers
- **Docker Support**: Well-documented Docker best practices and multi-stage builds
- **Community & Documentation**: Extensive community support and comprehensive documentation

**Alternatives Considered**:
- **Node.js/Express**: Faster development but less mature for enterprise features
- **Python/FastAPI**: Good for ML/AI integration but less suitable for Java-based teams
- **Go**: Excellent performance but higher learning curve for Java-based teams and less mature ecosystem/community support for enterprise features

**Consequences**:
- ‚úÖ Rapid development with auto-configuration
- ‚úÖ Rich ecosystem of libraries
- ‚úÖ Excellent documentation and community support
- ‚ö†Ô∏è Larger memory footprint compared to lightweight frameworks
- ‚ö†Ô∏è Slower startup time compared to native languages

---

### ADR 002: H2 Database Choice

**Context**: Need to choose a database for the assessment that is easy to set up and demonstrate, while being production-like.

**Decision**: Use H2 embedded database (file-based).

**Rationale**:
- **Zero Configuration**: Embedded database - no separate installation or Docker container needed
- **Built-in Web Console**: Accessible at `/h2-console` - perfect for assessment reviewers to browse data
- **Lightweight**: Minimal memory footprint, perfect for demos and assessments
- **SQL Compatibility**: Standard SQL syntax, easy to migrate to PostgreSQL/MySQL later
- **File-based Persistence**: Data persists across restarts when configured with file storage
- **Easy Setup**: Just add dependency - no external setup required for assessors
- **Production-like**: Can easily switch to PostgreSQL by changing configuration (Spring Boot profile)

**Alternatives Considered**:
- **PostgreSQL**: More production-ready but requires separate Docker container and setup
- **MySQL**: Similar to PostgreSQL, requires external setup
- **SQLite**: Lightweight but less feature-rich than H2

**Consequences**:
- ‚úÖ Zero external dependencies for setup
- ‚úÖ Built-in web console for data browsing
- ‚úÖ Easy migration path to PostgreSQL/MySQL
- ‚ö†Ô∏è Not suitable for high-concurrency production workloads
- ‚ö†Ô∏è Single-instance only (no distributed setup)

---

### ADR 003: API Key Authentication vs OAuth2

**Context**: Need to secure API endpoints. Choose between API key authentication and OAuth2/JWT.

**Decision**: Use API key authentication with primary/secondary key support for rotation.

**Rationale**:
- **Simplicity**: API key authentication is simpler to implement and understand
- **Microservice Context**: This is a backend service, not a user-facing application
- **Client Type**: Clients are other services (RAG chatbot systems), not end users
- **Rotation Support**: Primary/secondary key pattern enables zero-downtime key rotation
- **Rate Limiting**: API keys work well with per-key rate limiting
- **Assessment Scope**: Appropriate for the assessment scope and requirements

**Alternatives Considered**:
- **OAuth2/JWT**: More secure but adds complexity and requires token management
- **Basic Auth**: Less secure and not suitable for production
- **mTLS**: Overkill for this use case

**Consequences**:
- ‚úÖ Simple implementation and maintenance
- ‚úÖ Easy key rotation with primary/secondary pattern
- ‚úÖ Works well with rate limiting
- ‚ö†Ô∏è Less granular than OAuth2 (no per-user tokens)
- ‚ö†Ô∏è Keys must be securely stored and transmitted

---

### ADR 004: In-Memory vs Redis Rate Limiting

**Context**: Need to implement rate limiting. Choose between in-memory (Bucket4j) and distributed (Redis) rate limiting.

**Decision**: Use in-memory Bucket4j for rate limiting.

**Rationale**:
- **Assessment Scope**: Single-instance deployment is sufficient for assessment
- **Simplicity**: No external dependencies (Redis) required
- **Performance**: In-memory rate limiting is faster than distributed
- **Easy Setup**: No additional infrastructure to configure
- **Migration Path**: Can easily switch to Redis-based rate limiting for distributed deployments

**Alternatives Considered**:
- **Redis**: Better for distributed systems but adds complexity and external dependency
- **Guava RateLimiter**: Less feature-rich than Bucket4j
- **Spring Cloud Gateway**: Overkill for this microservice

**Consequences**:
- ‚úÖ No external dependencies
- ‚úÖ Fast in-memory performance
- ‚úÖ Simple setup and configuration
- ‚ö†Ô∏è Rate limits reset on application restart
- ‚ö†Ô∏è Not suitable for distributed/multi-instance deployments

---

### ADR 005: Cascade Delete Strategy

**Context**: When deleting a session, need to decide how to handle associated messages.

**Decision**: Use database-level cascade delete (ON DELETE CASCADE).

**Rationale**:
- **Data Integrity**: Ensures messages are always deleted when session is deleted
- **Performance**: Database-level cascade is more efficient than application-level deletion
- **Atomicity**: Single transaction ensures consistency
- **Simplicity**: No need for explicit message deletion logic in service layer

**Alternatives Considered**:
- **Application-level deletion**: More control but requires explicit queries and transactions
- **Soft delete**: Preserves data but adds complexity and storage overhead

**Consequences**:
- ‚úÖ Automatic message cleanup on session deletion
- ‚úÖ Better performance (single database operation)
- ‚úÖ Atomic operation (all-or-nothing)
- ‚ö†Ô∏è Cannot recover deleted messages (consider soft delete for production)

---

### ADR 006: User ID Format Restriction

**Context**: Need to define the format for `userId` input to balance flexibility and security.

**Decision**: Restrict `userId` to alphanumeric characters and underscore only (regex: `^[a-zA-Z0-9_]+$`).

**Rationale**:
- **Security**: Prevents log injection, path traversal, and XSS risks
- **Flexibility**: Supports common ID formats (UUIDs without hyphens, alphanumeric IDs)
- **Validation**: Simple regex validation is efficient
- **Storage**: VARCHAR(255) is sufficient for most use cases

**Alternatives Considered**:
- **Allow special characters**: More flexible but requires additional sanitization and security measures
- **UUID only**: Too restrictive for existing systems

**Consequences**:
- ‚úÖ Prevents injection attacks
- ‚úÖ Simple validation
- ‚úÖ Supports common ID formats
- ‚ö†Ô∏è Requires client systems to encode special characters (e.g., base64 for emails)

---

### ADR 007: Context Storage Format

**Context**: Need to decide how to store optional context data (retrieved documents from RAG).

**Decision**: Store context as TEXT column with JSON validation, optional GZIP compression for large contexts.

**Rationale**:
- **Flexibility**: TEXT column supports large contexts (up to 50KB)
- **Structure**: JSON format enables structured validation and parsing
- **Compression**: GZIP reduces storage for large contexts (>10KB)
- **Fallback**: Accept plain text if JSON validation fails

**Alternatives Considered**:
- **Separate table**: More normalized but adds complexity
- **BLOB storage**: Less queryable and harder to debug

**Consequences**:
- ‚úÖ Flexible storage for various context formats
- ‚úÖ Optional compression reduces storage
- ‚úÖ JSON validation ensures data quality
- ‚ö†Ô∏è Large contexts may impact query performance (consider indexing strategies)

## Testing

### Running Tests

```bash
# Run all tests
./mvnw test

# Run tests with coverage report
./mvnw test jacoco:report
```

### Test Coverage

<img width="1197" height="465" alt="image" src="https://github.com/user-attachments/assets/d136e7b9-2222-442c-bc39-e33af9dff88c" />


### Viewing Coverage Report

After running tests with coverage, view the JaCoCo report:

```bash
# Generate report
./mvnw test jacoco:report

# Open in browser (macOS)
open target/site/jacoco/index.html

# Open in browser (Linux)
xdg-open target/site/jacoco/index.html
```

The coverage report is available at: `target/site/jacoco/index.html`

### Manual Testing

Use the provided Postman collection (`docs/RAG_Chat_Storage.postman_collection.json`) for manual API testing.

## Troubleshooting

### Common Issues

#### 1. Application fails to start

**Error**: `API_KEY_PRIMARY is required`

**Solution**: Add `API_KEY_PRIMARY` to your `.env` file:

```bash
# Create .env file from example (if not exists)
cp env.example .env

# Edit .env and add your API key
# API_KEY_PRIMARY=your-primary-api-key
```

Or if you prefer using environment variables:

```bash
export API_KEY_PRIMARY=your-primary-api-key
```

#### 2. Database connection errors

**Error**: `Unable to create database file`

**Solution**: Ensure the `H2_DATABASE_PATH` directory exists and is writable:

```bash
mkdir -p ./data
chmod 755 ./data
```

#### 3. Port already in use

**Error**: `Port 8080 is already in use`

**Solution**: Change the port:

```bash
export SERVER_PORT=8081
# Or add to .env file: SERVER_PORT=8081
```

#### 4. H2 Console not accessible

**Solution**: Enable H2 console in dev profile:

```bash
export SPRING_PROFILES_ACTIVE=dev
export ENABLE_H2_CONSOLE=true
# Or add to .env file
```

#### 5. Rate limit errors

**Error**: `429 Too Many Requests`

**Solution**: Wait for the rate limit window to reset, or increase limits:

```bash
export RATE_LIMIT_API_KEY_PER_MINUTE=120
# Or add to .env file
```

#### 6. Docker container won't start

**Solution**: Check logs for errors:

```bash
# Check logs
docker-compose logs ragchat-storage

# Check container status
docker-compose ps

# Check health endpoint
curl http://localhost:8080/actuator/health
```

#### 7. Clear everything and start fresh

```bash
# Stop and remove containers, volumes, and networks
docker-compose down -v

# Remove unused Docker resources
docker system prune -f

# Rebuild and start
docker-compose up --build
```

### Logs

View application logs:

```bash
# Local
tail -f logs/ragchat-storage.log

# Docker
docker-compose logs -f ragchat-storage
```

### Health Checks

Check application health:

```bash
curl http://localhost:8080/actuator/health
```

Expected response: `{"status":"UP"}`

## Assessment Deliverables

This project fulfills all requirements from the Backend Developer Interview Case Study:

### ‚úÖ Core Functionalities
- Session management (create, retrieve, rename, favorite, delete)
- Message storage with sender, content, and optional context
- Message history retrieval with pagination

### ‚úÖ Technical Expectations
- Environment-specific configurations (`.env` files, Spring profiles)
- API key authentication (read from `.env` file or environment variables)
- Rate limiting (60 requests per minute per API key)
- Centralized logging (Logback with file and console appenders)
- Global error handling (RFC 7807 compliant)

### ‚úÖ Deliverables
- Source code in GitHub repository
- `.env.example` file documenting all environment variables
- `README.md` with setup instructions and API descriptions
- Swagger/OpenAPI documentation at `/swagger-ui.html`

### ‚úÖ Bonus Features
- Health check endpoints (`/actuator/health`)
- Swagger/OpenAPI documentation (`/swagger-ui.html`)
- H2 console accessible through browser (`/h2-console`)
- Unit tests for services with JaCoCo coverage reports
- CORS configuration for security
- Pagination support for message retrieval

## License

This project is created for assessment purposes.

## Contact

For questions or issues, please refer to the project documentation or create an issue in the repository.
